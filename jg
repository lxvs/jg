#!/bin/bash
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

pushd () {
    command pushd "$@" 1>/dev/null
}

popd () {
    command popd "$@" 1>/dev/null
}

# $1    : Color - red/yellow/green
# ...   : string lines
Prompt () {
    local -r RED="[91m"
    local -r GRN="[92m"
    local -r YLW="[93m"
    local -r RST="[0m"
    local -r COLOR_ARG="$1"
    local color
    shift
    case "$COLOR_ARG" in
    r|red) color="$RED" ;;
    g|grn|green) color="$GRN" ;;
    y|ylw|yellow) color="$YLW" ;;
    *)
        >&2 Prompt red "ERROR: Unknown color argument - $COLOR_ARG"
        return 1
        ;;
    esac
    printf "${color}%s${RST}\n" "$@"
}

ParseSwitchValue () {
    sw="$1"
    if test "$#" -ge 2 && ! grep -q '^-' <<<"$2"
    then
        val="$2"
        return
    fi
    >&2 Prompt red "ERROR: $sw requires a value."
    return 1
}

GetBeyondCompare () {
    local -r bc_reg_p='HKCU\Software\Scooter Software\Beyond Compare'
    local -r bc_reg_k="ExePath"
    bc="$JG_BC_PATH" && return
    if ! grep -qi '^win' <<<"$OS"
    then
        >&2 Prompt yellow "Sorry, this operation is Windows only for now."
        return 1
    fi
    bc=$(reg query "$bc_reg_p" //v "$bc_reg_k" 2>/dev/null)
    if test ! "$bc"
    then
        >&2 Prompt red "ERROR: Couldn't find Beyond Compare."
        return 1
    fi
    bc=$(grep "ExePath" <<<"$bc" | sed 's/\s\{4\}.*\s\{4\}//')
}

LookUpUsage () {
    while test $# -ge 1
    do
        case "$1" in
        -h|--help)
            ${op}Usage
            return 1
            ;;
        esac
        shift
    done
}

Usage () {
cat <<\USG
Usage:

    jg { -v | --version }
    jg { -h | --help }
    jg <command> [<args>]

Commands:

    batch, bcdiff, bcmerge, chid, push, dog, dogr, adog, dof, ghcr

Use 'jg <command> --help' for details.
USG
}

Logo () {
cat <<LOGO

    jg $VER
    $INFO

LOGO
}

batchUsage () {
cat <<\BATCHUSG
Usage:

    jg batch [<options>] <command> [<command-args> ...]

Execute <command> for each repo in current folder.

Options:

    -f, --force         do not break when error

Example:

    jg batch git pull --ff-only
BATCHUSG
}

batchOp () {
    local force="no"
    while test $# -ge 1
    do
        case "$1" in
        -h|--help)
            ${op}Usage
            return
            ;;
        -f|--force)
            force="yes"
            shift
            break
            ;;
        *)
            break
            ;;
        esac
    done
    for repo in $(ls -d */ 2>/dev/null)
    do
        test ! -e "$repo/.git" && continue
        pushd "$repo"
        Prompt yellow "$repo"
        test ! "$force" = "yes"
        "$@" || return
        popd
    done
}

bcdiffUsage () {
cat <<\BCDIFFUSG
Usage:

    jg bcdiff [<option>...]

Diff with Beyond Compare. <Option>, if any, will be passed to git difftool.
Try 'git difftool --help' for more information.

If you want to diff the staged changes, use 'jg bcdiff --cached'.

Path to Beyond Compare with be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
BCDIFFUSG
}

bcdiffOp () {
    local bc
    LookUpUsage "$@" || return
    git rev-parse || return
    GetBeyondCompare || return
    git -c "diff.tool=bcjg" \
        -c "difftool.bcjg.cmd=\"${bc}\" \"\$LOCAL\" \"\$REMOTE\"" \
        difftool --dir-diff "$@"
}

bcmergeUsage () {
cat <<\BCMERGEUSG
Usage:

    jg bcmerge [<file to merge> ...]

Resolve merge conflicts with Beyond Compare. If <file to merge> is not
specified, resolve all conflicted files one by one.

By default, git creates *.orig backup files while resolving merges. These
are safe to remove once a file has been merged and its git mergetool
session has completed.

Setting the mergetool.keepBackup configuration variable to false causes git
mergetool to automatically remove the backup as files are successfully
merged.

Path to Beyond Compare with be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
BCMERGEUSG
}

bcmergeOp () {
    local bc=
    LookUpUsage "$@" || return
    git rev-parse || return
    GetBeyondCompare || return
    git -c "merge.tool=bcjg" \
        -c "mergetool.bcjg.cmd=\"${bc}\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\"" \
        -c "mergetool.bcjg.trustExitCode=true" \
        mergetool "$@"
}

chidUsage () {
cat <<\CHIDUSG
Usage:

    jg chid [<Change-ID>]

Find a commit with given Gerrit Change-ID. If <Change-ID> is not specified,
get the Change-ID of the current commit.
CHIDUSG
}

chidOp () {
    local chid=
    local commit
    local args=
    if test $# = 0
    then
        git log -1 --format=%b |
            grep '^Change-Id: ' |
            sed 's/^Change-Id: //'
        return
    fi
    while test $# -ge 1
    do
        case "$1" in
        -h|--help)
            ${op}Usage
            return
            ;;
        -*)
            args="$args $1"
            shift
            ;;
        *)
            chid="$1"
            shift
            break
            ;;
        esac
    done
    git rev-parse || return
    test "$chid" || return
    commit=$(git log --all --format="%b%H" |
        sed -n "/^Change-Id: $chid[0-9a-f]\{,40\}\$/{n;p;q}")
    test "$commit" || return
    git show -s $args $commit $@
}

pushUsage () {
cat <<\PUSHUSG
Usage:

    jg push [-r <remote>] [<branch>] [<option> ...]

Push local commits to Gerrit. Default <remote> and <branch> are the current.
This command is equivalent to:

    git push [<option> ...] <remote> HEAD:refs/for/<branch>
PUSHUSG
}

pushOp () {
    local branch=
    local remote
    local up
    local rm_d
    local br_d
    local args=
    local sw
    local val
    while test $# -ge 1
    do
        sw="$1"
        case "$sw" in
        -h|--help)
            ${op}Usage
            return
            ;;
        -r|--remote)
            ParseSwitchValue "$@" || return
            remote="$val"
            shift 2
            ;;
        -*)
            args="$args $sw"
            shift
            ;;
        *)
            if test "$branch"
            then
                >&2 Prompt red "ERROR: Invalid argument: $sw"
                return 1
            else
                branch="$sw"
                shift
            fi
            ;;
        esac
    done
    git rev-parse || return
    br_d=$(git rev-parse --abbrev-ref HEAD) || return
    up=$(git rev-parse --abbrev-ref @{push}) || return
    rm_d="${up%/$br_d}"
    git push $args ${remote-$rm_d} HEAD:refs/for/"${branch-$br_d}"
}

dogUsage () {
cat <<DOGUSG
jg dog = git log --decorate --oneline --graph
jg adog = git log --all --decorate --oneline --graph
jg dof = git log --decorate --oneline --first-parent

You can use wildcards when specifying branches, but make sure to quote them
in this case, otherwise Shell will expand wildcards to filenames.

jg dogr is similar to jg dog; the only difference is that when wildcards
are used, dogr matches only remote branches while dog matches only local
ones.
DOGUSG
}

dogOp () {
    local brs
    LookUpUsage "$@" || return
    brs="$@"
    if printf "%s" "$@" | grep -q '\*\|\?'
    then
        dogOp_ParseArgs "$@" || return
    fi
    git log --decorate --oneline --graph $brs
}

dogOp_ParseArgs () {
    brs=
    local br=
    for arg in "$@"
    do
        if printf "%s" "$arg" | grep -q '\*\|\?'
        then
            br=$(git branch --format='%(refname:short)' ${isdogr+"-r"} \
                -l "$arg")
            if test ! "$br"
            then
                >&2 Prompt red "error: '$arg' matches no branch."
                return 1
            fi
            brs="$brs $br"
        else
            brs="$brs $arg"
        fi
    done
}

dogrUsage () {
    dogUsage
}

dogrOp () {
    local isdogr=1
    dogOp "$@"
}

adogUsage () {
    dogUsage
}

adogOp () {
    dogOp --all "$@"
}

dofUsage () {
    dogUsage
}

dofOp () {
    LookUpUsage "$@" || return
    git log --decorate --oneline --first-parent "$@"
}

ghcrUsage () {
cat <<EOF
usage: jg ghcr [<options>] <name>

Create a GitHub repository named <name>, which can only contains letters,
digits, '-', '.' and '_'.

Options:
    -u, --user <user>:<token>   GitHub username and access token
    -p, --private               Create a private repo instead

If not specified, <user> and <token> will be read from environment variable
JG_GH_USER and JG_GH_TOKEN.
EOF
}

ghcrOp () {
    local user= token= name= private
    local sw val
    ghcrOp_parse "$@" || return
    ghcrOp_validate || return
    curl -s -X POST \
        ${user:+-u $user${token:+:$token}} \
        -H "Accept: application/vnd.github.v3+json" \
        https://api.github.com/user/repos \
        -d "{\"name\": \"$name\"${private:+, \"private\": \"true\"}}"
}

ghcrOp_parse () {
    while test $# -ge 1
    do
        case "$1" in
        -h|--help)
            ${op}Usage
            exit
            ;;
        -u|--user)
            ParseSwitchValue "$@" || return
            if grep -q ':' <<<"$val"
            then
                user=$(awk -F: '{print $1}' <<<$"$val")
                token=$(awk -F: '{print $2}' <<<$"$val")
            else
                user="$val"
            fi
            shift 2
            ;;
        -p|--private)
            private=1
            shift
            ;;
        *)
            if test ! "$name"
            then
                name="$1"
                shift
                continue
            fi
            >&2 Prompt red "error: invalid argument: %s" "$1"
            return 1
            ;;
        esac
    done
}

ghcrOp_validate () {
    if test ! "$name"
    then
        >&2 Prompt red "error: Repo name is required."
        return 1
    fi
    if test "$(tr -d '[:alnum:]\-_.' <<<"$name")"
    then
        >&2 Prompt red \
            "error: Repo name can contain only letters, digits, '-', '.' and '_'."
        return 1
    fi
    test ! "$user" && user="$JG_GH_USER"
    test ! "$token" && token="$JG_GH_TOKEN"
    return 0
}

ParseArgs () {
    local op
    if test $# -eq 0
    then
        Logo
        Usage
        return
    fi
    case "$1" in
    -v|--ver|--version)
        Logo
        exit
        ;;
    -h|--help)
        Logo
        Usage
        exit
        ;;
    batch|bcdiff|bcmerge|chid|push|dog|dogr|adog|dof|ghcr)
        op="$1"
        shift
        ${op}Op "$@"
        return
        ;;
    *)
        >&2 Prompt red "ERROR: Invalid operation - $1"
        >&2 Usage
        return 1
        ;;
    esac
}

main () {
    local -r VER="2.3.1"
    local -r INFO="https://github.com/lxvs/jg"
    local JG_BC_PATH=${JG_BC_PATH-}
    local JG_GH_USER=${JG_GH_USER-}
    local JG_GH_TOKEN=${JG_GH_TOKEN-}
    local OS=${OS-}
    ParseArgs "$@" || return
}

main "$@"
